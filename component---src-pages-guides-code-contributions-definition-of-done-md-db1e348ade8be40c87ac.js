(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[78],{3208:function(e,t,a){"use strict";a.r(t),a.d(t,{_frontmatter:function(){return r},default:function(){return m}});var n=a(2122),o=a(9756),i=(a(5007),a(4983)),s=a(9536),l=["components"],r={},d={_frontmatter:r},c=s.Z;function m(e){var t=e.components,a=(0,o.Z)(e,l);return(0,i.mdx)(c,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"definition-of-done"},"Definition of done"),(0,i.mdx)("p",null,'The "Definition of Done" (DoD) is a collective term for a set of acceptance criteria that is applied to any changes in the product code base. The requirements that result from our DoD are applied by default to all Adobe-owned repositories.'),(0,i.mdx)("p",null,"Internally, the Adobe development teams follow the DoD to ensure that all work meets consistent release criteria. We encourage our community contributors to also follow the definition of done."),(0,i.mdx)("p",null,'At a high level, the criteria defined in our "definition of done" revolve around the principle of writing clean code that is reviewed and includes unit tests and solid documentation along with the code.'),(0,i.mdx)("p",null,"The following sections provide additional details about each of these criteria:"),(0,i.mdx)("h2",{id:"backward-compatibility"},"Backward compatibility"),(0,i.mdx)("h3",{id:"functional-backward-compatibility"},"Functional backward compatibility"),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Functional backward compatibility")," means the behaviour of the application is preserved."),(0,i.mdx)("p",null,'Existing product features and functionality must be retained during any changes to the code.\nAny backward-compatible functional changes must be approved by a product owner.\nThe documentation should explain the justification and provide the "business value".'),(0,i.mdx)("h3",{id:"technical-backward-compatibility"},"Technical backward compatibility"),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Technical backward compatibility")," means the technical interfaces are preserved."),(0,i.mdx)("p",null,"Technical interfaces include PHP interfaces or classes, CLI commands, URLs or any other interfaces that can be used by 3rd-party developer, system integrator, or user of Magento Open Source.\nAny change to an interface that can lead to a broken integration is a breaking technical change.\nTechnical interfaces and the corresponding level of change is described in ",(0,i.mdx)("a",{parentName:"p",href:"https://devdocs.magento.com/guides/v2.4/extension-dev-guide/versioning/codebase-changes.html"},"Code Changes")," and ",(0,i.mdx)("a",{parentName:"p",href:"https://devdocs.magento.com/guides/v2.4/extension-dev-guide/versioning/dependencies.html"},"Module Version Dependencies")," documents in more details."),(0,i.mdx)("p",null,"Technical backward compatibility must be retained between PATCH (marketing) versions of Magento Open Source. It should also be retained between MINOR (marketing) releases if possible.\nAny breaking changes must be approved by an architect, product owner and release manager."),(0,i.mdx)("p",null,"For more information, see the ",(0,i.mdx)("a",{parentName:"p",href:"backward-compatibility-policy.md"},"backward compatibility policy")," and ",(0,i.mdx)("a",{parentName:"p",href:"https://devdocs.magento.com/guides/v2.4/extension-dev-guide/versioning/index.html"},"Versioning")," documents."),(0,i.mdx)("h2",{id:"documentation"},"Documentation"),(0,i.mdx)("p",null,"All changes, additions, and extensions to the product should be documented by the author.\nThe documentation should provide an overview of the change, and information about standard use cases, audience, and procedural instructions for implementing the feature."),(0,i.mdx)("p",null,"Documentation for the submitted code should be submitted as a pull request to the official DevDocs ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/magento/devdocs"},"repository"),"."),(0,i.mdx)("p",null,"When submitting either code or documentation, a brief summary of the work should be included in the commit message."),(0,i.mdx)("p",null,"Additionally, the code itself should follow our ",(0,i.mdx)("a",{parentName:"p",href:"https://devdocs.magento.com/guides/v2.4/coding-standards/docblock-standard-general.html"},"DocBlock standard")," and contain high-quality comments and descriptions for all classes and methods."),(0,i.mdx)("p",null,"For documenting backward-compatible changes, please see ",(0,i.mdx)("a",{parentName:"p",href:"backward-compatibility-policy.md#where-to-document"},"Backwards Compatible Development"),"."),(0,i.mdx)("h2",{id:"tests"},"Tests"),(0,i.mdx)("h3",{id:"understanding-black-white-and-gray-tests"},"Understanding black, white, and gray tests"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"A black box test does not have any knowledge of how the subject of the test is built."),(0,i.mdx)("li",{parentName:"ul"},"A white box has knowledge of how the subject of the test is built. The test logic is usually coupled to the implementation and will typically be sensitive to changes."),(0,i.mdx)("li",{parentName:"ul"},"A gray box is similar to black box testing where the test is not directly coupled to the subject's implementation but the test cases may be designed in a way to assert that sensitive portions of the implementation will work correctly.")),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("p",null,"Assume there is a method with the signature ",(0,i.mdx)("inlineCode",{parentName:"p"},"function removeLetterFromString(string $letter, string $string): string")),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"A black box test would test the obvious cases both normal cases such as ",(0,i.mdx)("inlineCode",{parentName:"li"},"removeLetterFromString('a', 'fooabar') === 'foobr'")," and edge cases such as when ",(0,i.mdx)("inlineCode",{parentName:"li"},"$letter")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"$string")," are empty or ",(0,i.mdx)("inlineCode",{parentName:"li"},"$letter")," contains multiple or multibyte characters. It would probably test several variations of string lengths. Notice there is no knowledge of how this function is written."),(0,i.mdx)("li",{parentName:"ul"},"A white box test would look into the implementation of the method and see that it calls a microservice API and make sure that each condition of the code has test coverage. For example, this test may force the microservice client to return an error and have a test for the expected handling of that scenario. This wouldn't be a reusable test and it's directly coupled to the implementation."),(0,i.mdx)("li",{parentName:"ul"},"A gray box test would look at the implementation of the method and see that it calls a microservice API and injects the ",(0,i.mdx)("inlineCode",{parentName:"li"},"$string")," into the URL so it may add some extra test coverage for strings that contain unsafe URL characters such as ",(0,i.mdx)("inlineCode",{parentName:"li"},"&?=%/"),". This is not coupled to the implementation as the implementation could be changed and the test should still pass.")),(0,i.mdx)("h3",{id:"automated-tests"},"Automated tests"),(0,i.mdx)("p",null,"Code changes must be covered by automated tests according to Classification of Automated Tests.\nWhen choosing how to cover your changes, pick the most lightweight (execution time wise) test type that will provide sufficient coverage.\nIf you encounter an existing test that insufficiently covers your changes, you can delete that test but you must write a proper test to replace it. For example, a method that interacts with database has a unit test. You can replace it with an integration test."),(0,i.mdx)("p",null,"Be aware that while high-level tests may provide coverage to code, it is only indirect coverage. Tests with more direct usage of the changed code will likely still needs to be written to ensure that regardless of the which components are actually used in the black box, the individual components still have coverage."),(0,i.mdx)("p",null,"High level testing policy:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Any code that is added or changed must have explicit tests to validate the behavior. To clarify, this policy is intended to prove that the integrity of the code is verified regardless of which implementations are loaded in a black box environment. This may be done through unit or integration testing as appropriate.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Code must be also shown to work with known collaborators. This must be done through integration tests and ideally should involve as few components as possible per test case. This level of tests ensures that the code will work with its known associates. Specific examples can be subject but such associates would include composites, chains, pools, etc. but also include cases like a Template filter working with a specific processor loaded.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"In addition, regardless of the interpretation of the testing strategy below: Any class marked with an ",(0,i.mdx)("inlineCode",{parentName:"p"},"@api")," annotation MUST be covered with explicit test coverage via integration or unit tests."),(0,i.mdx)("p",{parentName:"li"},"These tests must test the concrete implementation's behavior in a way that can not be inadvertently changed outside of the test itself."),(0,i.mdx)("p",{parentName:"li"},"For example: testing a concrete class through DI preference is not safe because it could be overridden via configuration of another loaded module. The test should not ask for the interface but rather the concrete implementation."))),(0,i.mdx)("h3",{id:"integration-tests"},"Integration tests"),(0,i.mdx)("p",null,"An integration test should be used to cover any code that does not meet the requirements of a unit test or functional test and should be thought of as essentially the default test type."),(0,i.mdx)("p",null,"Integration tests come in many forms and can drastically vary in definition depending on what the intention of the test is. Generally speaking an integration test verifies that two or more things work together correctly. i.e. We are testing the ",(0,i.mdx)("em",{parentName:"p"},"integration")," of one thing with another thing.\nFor the purpose of testing, there are essentially two broad categories of integration tests: narrow-form and broad-form."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Narrow-form integration tests focus on testing something mostly in isolation an can be as simple as a unit test as described in this guide except without mocked dependencies."),(0,i.mdx)("li",{parentName:"ul"},"Broad-form integration tests focus on testing something with less isolation and will involve multiple components explicitly collaborating. (compared to narrow-form where the dependencies are implicit collaborating)")),(0,i.mdx)("p",null,"Integration test policy:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Methods and classes must have black box or gray box test coverage, including all variations for normal use, as well as edge-cases.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"SPIs must have test coverage. Often times, Magento Open Source has extension points that may only be utilized by extension developers. Use TestModules to implement those SPI extension points and verify they are used correctly.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"As mentioned above, classes marked with ",(0,i.mdx)("inlineCode",{parentName:"p"},"@api")," must contain coverage. Integration tests must be used cover these classes unless a unit test is more appropriate. This includes JS modules and components.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Consumers of default SPI implementations should have at least basic coverage that ensures the default implementations of the SPI are correctly configured and loaded."),(0,i.mdx)("p",{parentName:"li"},"For example, ",(0,i.mdx)("inlineCode",{parentName:"p"},"Magento\\Framework\\SomeClassFilter")," may contain a ",(0,i.mdx)("inlineCode",{parentName:"p"},"FilterPool")," that comes with default ",(0,i.mdx)("inlineCode",{parentName:"p"},"FilterInterface"),"'s from ",(0,i.mdx)("inlineCode",{parentName:"p"},"Magento\\Framework"),". Each of these implementations would have their own coverage pursuant to this document. However, there should also be some basic assertions within the test coverage for ",(0,i.mdx)("inlineCode",{parentName:"p"},"Magento\\Framework\\SomeClassFilter")," that ensure each of the default filters are loaded correctly.\nThis should not be explicit coverage such as ",(0,i.mdx)("inlineCode",{parentName:"p"},"$filter->isLoaded('someDefaultFilter')"),"."))),(0,i.mdx)("p",null,"See: ",(0,i.mdx)("a",{parentName:"p",href:"https://devdocs.magento.com/guides/v2.4/test/integration/integration_test_execution.html"},"Running Integration Tests"),"."),(0,i.mdx)("h3",{id:"functional-tests"},"Functional tests"),(0,i.mdx)("p",null,"UI functional tests are inherently unstable regardless of platform or testing framework. For this reason, along with reasons of maintainability and quality assurance delivery time, these tests should be prioritized below all other tests types."),(0,i.mdx)("p",null,"Functional test policy:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Web API endpoints must have functional test coverage via api-functional tests. These tests should ensure that the endpoints behave in accordance to their service contracts regardless of the actual concrete implementation that may be loaded."),(0,i.mdx)("li",{parentName:"ul"},"For UI-related code, there are some circumstances where it is not possible to cover changes with unit or integration tests. In these cases the appropriate type of coverage would be a functional test but this is a last resort only.\nHowever, aside from those cases UI functional tests should only be used to cover P0/P1 testing scenarios. If there are no scenarios available to make this decision, a product owner must be consulted for approval of new tests.")),(0,i.mdx)("p",null,"If there is a scenario that is not classified as a P0/P1 but should be, have a discussion with the product owner to get it elevated."),(0,i.mdx)("p",null,"See ",(0,i.mdx)("a",{parentName:"p",href:"https://devdocs.magento.com/guides/v2.4/test/testing.html"},"Functional Tests"),"."),(0,i.mdx)("h3",{id:"unit-tests"},"Unit tests"),(0,i.mdx)("p",null,"There are a small number of use cases for unit tests. The nature of our code and development practices make it increasingly hard to write and maintain high-quality unit tests.\nMany of them end up being replaced by integration tests or are practically useless from the beginning due to how much mocking is needed to make them pass.\nGenerally, an integration test is the preferred test type."),(0,i.mdx)("p",null,"A unit test may be preferred when you have classes or methods that:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Have few or no dependencies.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"The test must not be directly coupled to the collaborators of the test subject. If the collaborators are solely responsible for the behavior of the tested subject, it will not be a good unit test."))),(0,i.mdx)("li",{parentName:"ul"},"Do not interact with resources such as databases, the file system, 3rd party systems, etc."),(0,i.mdx)("li",{parentName:"ul"},"Can be covered by a black box test.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"The test must not be a mirror of the code. Instead, the test must validate that the contract of the method or class is upheld by the implementation. Specific implementations may be weak in certain areas so specific corner cases could cover that logic while still being a black box test."))),(0,i.mdx)("li",{parentName:"ul"},"Would not be easily foreseen to have dependencies in the future.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"This can be hard to predict but a good example of when it would be unlikely is a simple utility class that performs some standalone operation. By contrast, a helper would be very likely to have dependencies by nature.")))),(0,i.mdx)("p",null,"Examples:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Utility classes such as ",(0,i.mdx)("inlineCode",{parentName:"li"},"\\Magento\\Framework\\Math\\Random"),"."),(0,i.mdx)("li",{parentName:"ul"},"Simple classes that can also be used independently such as ",(0,i.mdx)("inlineCode",{parentName:"li"},"\\Magento\\Framework\\Api\\SortOrder"),"."),(0,i.mdx)("li",{parentName:"ul"},"Algorithms that perform calculation or parsing.")),(0,i.mdx)("p",null,"And by explicit contrast here are some things NOT to cover:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Classes/methods with numerous dependencies.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Creation of unit tests for such classes will result in the creation of many mocks and writing complex test logic (that most likely follows code to large extend and as a result we will have fragile and hard to maintain tests)"))),(0,i.mdx)("li",{parentName:"ul"},"Classes/methods interacting with resources directly or indirectly."),(0,i.mdx)("li",{parentName:"ul"},"Glue/wiring",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Mostly passing data between collaborators and has no or small amount of logic so it can be covered indirectly by integration/functional tests.")))),(0,i.mdx)("p",null,"Examples:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Controllers",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},'They are the "glue" that connects different app layers. They should not contain any business logic and should only be responsible for directing request/response information to/from services. They can be tested via integration or functional tests. Also, controller-specific tests will likely be rendered useless and ultimately deleted at some point in the context of the service isolation initiative which makes this idea much more important.'))),(0,i.mdx)("li",{parentName:"ul"},"Model triad classes (Model/Resource Model/Collection)",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"They have many dependencies and interact with resources."))),(0,i.mdx)("li",{parentName:"ul"},"Factories")),(0,i.mdx)("h3",{id:"integrity-tests"},"Integrity tests"),(0,i.mdx)("p",null,"Code to cover:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Must cover any code which introduces convention in scope of a particular implementation, violation of which would lead to runtime error.")),(0,i.mdx)("p",null,"Expected code coverage:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Must cover all files applicable to this convention.")),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Scan for all XML-files of certain type and validate them using appropriate XML-schema."),(0,i.mdx)("li",{parentName:"ul"},'Scan for declarations of templates and invoke "fallback" mechanism to ensure they resolve.')),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Static Code Analysis:")),(0,i.mdx)("p",null,"Code to cover:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},'Must cover all new code files (or whatever qualifies as "new").')),(0,i.mdx)("p",null,"Expected code coverage: must cover all applicable files in entire code base."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Legacy Tests:")),(0,i.mdx)("p",null,"Code to cover:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Must cover any formal backward-compatible changes on code level.\nFor more information, see ",(0,i.mdx)("a",{parentName:"li",href:"backward-compatibility-policy.md"},"backward compatibility policy"),".")),(0,i.mdx)("p",null,"A failure in a legacy test must provide comprehensive explanation of an alternative, if there is any."),(0,i.mdx)("p",null,"Expected code coverage:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Must cover the majority of occurrences of the backward-compatible change."),(0,i.mdx)("li",{parentName:"ul"},"Should cover 100% of occurrences.")),(0,i.mdx)("p",null,"Not all changes can be covered.\nFor example, it is possible to scan a file for literals, but it is unfeasible to analyze string concatenation or any other dynamic way of building a variable."),(0,i.mdx)("h3",{id:"functional-manual-tests"},"Functional manual tests"),(0,i.mdx)("p",null,"Must cover new or changed application behavior (functional).\nAdded/updated functionality should be covered by a functional Zephyr test(s) related to current sprint commitment."),(0,i.mdx)("h2",{id:"review"},"Review"),(0,i.mdx)("p",null,"A task, when complete by the author, should be reviewed by another Magento Open Source community member through a process of formal code review.\nThe reviewer should check whether the task meets the original acceptance criteria and verify that there are no code defects and that all points of this definition of done are met."),(0,i.mdx)("p",null,"The work cannot be considered as complete unless all the criteria are verified."))}m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-guides-code-contributions-definition-of-done-md-db1e348ade8be40c87ac.js.map